<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="HubHandling" #>
<#@ assembly name="$(TargetDir)HubHandling.dll" #>
<#@ import namespace="PythonExecution" #>
<#@ assembly name="$(TargetDir)PythonExecution.dll" #>
<#@ output extension=".cs" #>
<#
            Type type =  typeof(IExecutable);
            List<string> methodNames = new List<string>();
            List<bool> returnValues = new List<bool>();
            Dictionary<string,List<string>> parameterTypes = new Dictionary<string,List<string>>();
            Dictionary<string,List<string>> parameterNames = new Dictionary<string,List<string>>();
            MethodInfo[] methodInfos = type.GetMethods();
            foreach(MethodInfo methodInfo in methodInfos)
            {
                string methodName = methodInfo.Name;
                methodNames.Add(methodName);
                if(methodInfo.ReturnType.ToString() != "System.Void"){
                    returnValues.Add(true);
                }else{
                    returnValues.Add(false); 
                }
                List<string> paramTypes = new List<string>();
                List<string> paramNames = new List<string>();
                foreach(ParameterInfo parameterInfo in methodInfo.GetParameters())
                {
                    string parameterTypeName = parameterInfo.ParameterType.Name;
                    string parameterName = parameterInfo.Name;
                    paramTypes.Add(parameterTypeName);
                    paramNames.Add(parameterName);
                }
                parameterTypes.Add(methodName,paramTypes);
                parameterNames.Add(methodName,paramNames);
            }
#>
using System;
using Microsoft.AspNet.SignalR.Client;
using PythonExecution;

namespace HubHandling
{
    public class HubCallback
    {
        IHubProxy _hubProxy;
        public HubCallback(IHubProxy hubProxy)
        {
            _hubProxy = hubProxy;
            <#
            for(int i = 0; i<methodNames.Count ; i++)
            {
                WriteLine(methodNames[i]+"();");
            }
            #>
        }
        
        <#
        for(int i = 0; i<methodNames.Count ; i++)
        {
            string methodName = methodNames[i];
            bool returnType = returnValues[i];
            string typeList = String.Join(",",parameterTypes[methodName]);
            string paramList = String.Join(",",parameterNames[methodName]);
            WriteLine("public void "+methodName+"()");
            WriteLine("{");
            WriteLine("Executable executable = new Executable();");
            
            if(returnType){
                WriteLine("_hubProxy.On<"+typeList+">(\""+methodName+"\", ("+paramList+") => ");
                WriteLine("{");
                WriteLine("ExecutionStack.Insert(()=>{");
                WriteLine("var response = executable."+methodName+"("+paramList+");");
                WriteLine("HubConnector.Instance.Proxy.Invoke<string>(\"SendResult\",new object[]{\""+methodName+"_result\", response});");
                WriteLine("},\""+methodName+"\",new object[]{"+paramList+"});");
                WriteLine("");
                WriteLine("});");
            }else{
WriteLine("_hubProxy.On<"+typeList+">(\""+methodName+"\", ("+paramList+") => ");
WriteLine("{");
WriteLine("ExecutionStack.Insert(()=>{");
WriteLine("executable."+methodName+"("+paramList+");");
WriteLine("},\""+methodName+"\",new object[]{"+paramList+"});});");
            }
            WriteLine("}");
        }
        #>
    }
}
